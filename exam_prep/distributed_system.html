<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Exam Search: Distributed Systems</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- UIkit CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uikit@3.5.3/dist/css/uikit.min.css" />

    <!-- UIkit JS -->
    <script src="https://cdn.jsdelivr.net/npm/uikit@3.5.3/dist/js/uikit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uikit@3.5.3/dist/js/uikit-icons.min.js"></script>

    <link rel="stylesheet" href="main.css" />
</head>
<body>

<input id="search_bar" class="uk-input search" onkeyup="search()" type="text" name="search" placeholder="search...">

<center>
    <div id="distributed systems definition introduction" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>Definition of Distributed Systems</h3>
        </div>
        <div class="uk-card-body">
            A distributed system consists of a collection of
            autonomous computers, connected through a
            network and distribution middleware, which
            enables computers to coordinate their activities
            and to share the resources of the system, so that
            users perceive the system as a single, integrated
            computing facility.
        </div>
    </div>

    <div id="properties and common goals of distributed systems introduction" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>Common Goals and properties of distributed systems</h3>
        </div>
        <div class="uk-card-body">
            A distributed system may have a common goal, such as solving a large computational
            problem.

            Alternatively, each computer may have its own user with individual needs, and the
            purpose of the distributed system is to coordinate the use of shared resources or
            provide communication services to the users.

            Other typical properties of distributed systems include the following:

            The system has to tolerate failures in individual computers.

            The structure of the system (network topology, network latency, number of computers)
            is not known in advance, the system may consist of different kinds of computers and
            network links, and the system may change during the execution of a distributed
            program.

            Each computer has only a limited, incomplete view of the system. Each computer may
            know only one part of the input.
        </div>
    </div>

    <div id="parallel and distributed computing characteristics" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>Parallel and Distributed Computing</h3>
        </div>
        <div class="uk-card-body">
            In parallel computing, all
            processors may have access
            to a shared memory to
            exchange information
            between processors.

            <hr>

            In distributed computing,
            each processor has its own
            private memory (distributed
            memory). Information is
            exchanged by passing
            messages between the
            processors.
        </div>
    </div>

    <div id="introduction to distributed systems system architecture user perception" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>System architecture</h3>
        </div>
        <div class="uk-card-body">
            the machines are autonomous; this means they are
            computers which, in principle, could work independently.
            <hr>
            <b>User Perception:</b>
            the distributed system is perceived as a single system
            solving a certain problem (even though, in reality, we have several computers
            placed in different locations).

            The distributed system has following characteristics:

            They do not have share memory or clock

            The computers communicate between themselves by the exchanging messages
            over a communication network

            Each computer has its own memory and operating system
        </div>
    </div>

    <div id="advantages of distributed systems system" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>Advantages of Distributed Systems</h3>
        </div>
        <div class="uk-card-body">
            Performance:
            very often a collection of processors can provide higher   performance (and better price/performance ratio) than a Centralized computer.
            <hr>
            Distribution:
            many applications involve, by their nature, spatially separated machines banking, Commercial, automotive system).
            <hr>
            Reliability (fault tolerance):
            if some of the machines crash, the system can survive.
            <hr>
            Incremental growth:
            as requirements on processing power grow, new machines can be added incrementally.
            <hr>
            Sharing of data/resources:
            shared data is essential to many applications (banking,  computer supported
            Cooperative work, reservation systems)
            other resources can be also shared (e.g. expensive printers).
            <hr>
            Communication:
            facilitates human-to-human communication.

        </div>
    </div>

    <div id="disadvantages of distributed computing" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>Disadvantages of distributed computing</h3>
        </div>
        <div class="uk-card-body">
            Difficulties of developing distributed software:
            how should operating systems, programming languages and applications look like?
            <hr>
            Networking problems
            several problems are created by the network infrastructure, which have to be dealt with: loss of messages, overloading.
            <hr>
            Security problems
            sharing generates the problem of data security.
        </div>
    </div>

    <div id="centralised and distributed computing characteristics" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>Centralized & Distributed System characteristics</h3>
        </div>
        <div class="uk-card-body">
            <b>Centralised Computing</b><br>
            One component with non-autonomous Parts<br>
            Component shared by users all the time<br>
            All resources accessible<br>
            Software runs in a single process<br>
            Single Point of control<br>
            Single Point of failure
            <hr>
            <b>Distributed Computing</b><br>
            Multiple autonomous components<br>
            Components are not shared by all users<br>
            Resources may not be accessible<br>
            Software runs in concurrent processes on different processors<br>
            Multiple Points of control<br>
            Multiple Points of failure

        </div>
    </div>

    <div id="what are we trying to achieve when we construct a distributed system resource sharing openness concurrency scalability fault tolerance transparency access location migration replication failure performance relocation persistence" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>What are we trying to achieve when we construct a distributed system?</h3>
        </div>
        <div class="uk-card-body">
            Certain common characteristics can be used to assess distributed systems<br><br>
            • <b>Resource Sharing</b><br>
            Ability to use any hardware, software or data anywhere in the system.<br>

            Resource manager controls access, provides naming scheme and controls concurrency.<br>

            Resource sharing model (e.g. client/server or object-based) describing how<br>
            - resources are provided,<br>
            - they are used and<br>
            - provider and user interact with each other.<br><br>

            • <b>Openness</b><br>
            Openness is concerned with extensions and improvements of distributed systems.<br>

            Detailed interfaces of components need to be published.<br>
            New components have to be integrated with existing components.<br>

            Differences in data representation of interface types on different processors (of different vendors) have to be resolved.<br><br>

            • <b>Concurrency</b><br>

            Components in distributed systems are executed in concurrent processes.<br>

            Components access and update shared resources (e.g. variables, databases, device drivers).<br>

            Integrity of the system may be violated if concurrent updates are not coordinated.<br>
            - Lost updates<br>
            - Inconsistent analysis<br><br>

            • <b>Scalability</b><br>
            Adaption of distributed systems to<br>
            - accommodate more users<br>
            - respond faster (this is the hard one)<br>

            Usually done by adding more and/or faster processors.<br>

            Components should not need to be changed when increases scale of a system.<br>

            Design components to be scalable!<br><br>

            • <b>Fault Tolerance</b><br>
            Hardware, software and networks fail!<br>

            Distributed systems must maintain availability even at low levels of hardware/software/network reliability.<br>

            Fault tolerance is achieved by<br>
            - recovery<br>
            - redundancy<br><br>

            • <b>Transparency</b><br>
            Distributed systems should be perceived by users and application programmers as a whole rather than as a collection of cooperating components.<br>

            Transparency has different dimensions.<br>

            These represent various properties that distributed systems should have.<br><br>

            - <b>Access Transparency:</b> Local and remote resources are accessed using identical operations.<br>
            - <b>Location Transparency:</b> Users are unaware of the location of resources<br>
            - <b>Migration Transparency:</b> Resources can migrate without name change<br>
            - <b>Replication Transparency:</b> Users are unaware of the existence of multiple copies of resources<br>
            - <b>Failure Transparency:</b> Users are unaware of the failure of individual components<br>
            - <b>Concurrency Transparency:</b> Users are unaware of sharing resources with others<br>
            - <b>Performance transparency:</b> load variation should not lead to performance degradation. This could be achieved by automatic reconfiguration as response to changes of the load; it is difficult to achieve.<br>
            - <b>Relocation Transparency:</b> Hide that a resource may be moved to another location while in use (the others don’t notice).<br>
            - <b>Persistence Transparency:</b> Hide whether a (software) resource is in memory or on disk<br>
        </div>
    </div>

    <div id="issues in distributed systems global knowledge naming scalability compatibility process synchronisation resource management security structuring" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>Issues in distributed systems</h3>
        </div>
        <div class="uk-card-body">
            • <b>Global Knowledge</b><br>
            Due to the unavailability of global clock and shared memory and unpredictable message delay, it is impossible to to collect the upto date information about the global state<br><br>

            • <b>Naming</b><br>
            Names are used to refer the objects. A name  service map a logical name to the physical address by making use of lookup table<br><br>

            • <b>Scalability</b><br>
            Grow with time<br><br>

            • <b>Compatibility</b><br>
            Three level of compatibility exist in DS<br>
            - Binary level<br>
            - Execution level<br>
            - Protocol level<br><br>

            • <b>Process synchronization</b><br>
            The synchronization is DS is difficult because of the unavailable of shared memory
            Problem of mutual exclusion<br><br>

            • <b>Resource management</b><br>
            Resource management concern with both local and remote resources available to user in an effective manner<br><br>

            • <b>Security</b><br>
            Authentication and authorization<br><br>

            • <b>Structuring</b><br>

        </div>
    </div>

    <div id="system models model architectural application architecture middleware operating platform rpc rmi corba java microsoft dcom web services client server and peer to peer thin fat" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>System Models</h3>
        </div>
        <div class="uk-card-body">
            Systems that are intended for use in real world environment should be designed to function correctly in the widest possible range of circumstances and in the face of many possible difficulties and threats.<br><br>

            Earlier slides shows that DS of different types share important underlying properties and give rise to design problems.<br><br>

            Here we are going to discuss common properties and design issues for distributed systems in the form of descriptive models.<br><br>

            Each model is intended to provide an abstract, simplified but consistent description of a relevant aspect of distributed system design.<br><br>

            • <b>Architectural Model</b><br>
            defines the way in which the component of system interact with each another and the way they have been implemented in the network.<br><br>

            These models are basically concern with the placement of system and its part and the relationship that exist between them. The goal of architecture model is to meet the current needs as well as the need of future<br><br>
            - <b>Software Architecture</b><br>
            It refers to the structuring of software as layers or modules in a single computer and in terms of services offered and requested between processes located in the same or different computers. These process and service oriented views can be expressed as service layers.<br>
            <pre>
                Application services
                middle ware
                operating system ____________platform
                computer & nw h/w ______|
            </pre>
            <b>Platform</b><br>
            The lowest level hardware and software layers are referred as platform to distributed system and their application.<br>

            These low level layers provide services to the layers above them.<br>

            Intel x86/ Windows, Intel x86/Solarsis, Intel x86/Linux, PowerPC/Mac OS X are major example of hardware and software layers.<br><br>

            <b>Middle Ware</b><br>
            It is layer of software whose purpose is to mask heterogeneity and to provide a convenient programming model to application programmers.<br>
            The goal of middleware is to create system independent interfaces for distributed applications.<br>
            The principle aim of middleware, namely raising the level of abstraction for distributed programming, is achieved in three ways.<br><br>

            communication mechanisms that are more convenient and less error prone than basic message passing;<br>
            independence from OS, network protocol, programming language, etc. and<br>
            standard services (such as a naming service, transaction service, security service, etc.).<br><br>

            To make the integration of these various services easier, and to improve transparency and system independence, middleware is usually based on a particular paradigm, or model, for describing distribution and communication.<br><br>

            <b>RPC</b> (Sun RPC) and group communication systems such as Isis were amongst the earliest instances of middleware. Object-oriented middleware products and standards are widely used, such as<br>
            <b>Java RMI</b> (Remote Method Invocation)<br>
            <b>CORBA</b> (Common Object Request Broker Architecture)<br>
            Web services<br>
            <b>Microsoft DCOM</b> (Distributed Component Object Model)<br><br>


            - <b>System Architecture</b><br>

            A distributed system is composed of a number of elements, the most important of which are software components, processing nodes and networks.<br>

            Some of these elements can be specified as part of a distributed system’s design, while others are given.<br>

            Typically when building a distributed system, the software is under the designer’s control.<br>

            Depending on the scale of the system, the hardware can be specified within the design as well, or already exists and has to be taken as-is.<br>

            The key, however, is that the software components must be distributed over the hardware components in some way.<br><br>

            The software of distributed systems can become fairly complex—especially in large distributed systems—and its components can spread over many machines.<br>
            It is important, therefore, to understand how to organize the system.<br>
            The software architecture of distributed systems deals with how software components are organized and how they work together, i.e., communicate with each other.<br>
            Once the software components are instantiated and placed on real machines, then the actual system architecture comes into picture.<br>
            <b>Client Server</b> and <b>Peer to Peer</b><br><br>

            <b>Client Server Architecture</b><br>
            The client-server architecture is the most common and widely used model for communication between processes.<br>
            In this architecture one process takes on the role of a server, while all other processes take on the roles of clients.<br>
            The server process provides a service (e.g., a time service, a database service, a banking service, etc.) and the clients are customers of that service.<br>
            A client sends a request to a server, the request is processed at the server and a reply is returned to the client.<br>
            A typical client-server application can be decomposed into three logical parts: the interface part, the application logic part, and the data part.<br><br>

            Implementations of the client-server architecture vary with regards to how the parts are separated over the client and server roles.<br>
            A <b>thin client</b> implementation will provide a minimal user interface layer, and leave everything else to the server.<br>
            A <b>fat client</b> implementation, on the other hand, will include all of the user interface and application logic in the client, and only rely on the server to store and provide access to data.<br>
            Implementations in between will split up the interface or application logic parts over the clients and server in different ways.<br><br>

        </div>
    </div>

    <div id="vertical distribution multi tier" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>Vertical Distribution</h3>
        </div>
        <div class="uk-card-body">
            An extension of the client-server architecture, the vertical distribution, or multi-tier, architecture distributes the traditional server functionality over multiple servers.<br>
            A client request is sent to the first server.<br>
            During processing of the request this server will request the services of the next server, who will do the same, until the final server is reached.<br>
            In this way the various servers become clients of each other. Each server is responsible for a different step (or tier) in the fulfillment of the original client request.<br>

        </div>
    </div>

    <div id="horizontal distribution multi tier" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>Horizontal Distribution</h3>
        </div>
        <div class="uk-card-body">
            While vertical distribution focuses on splitting up a server’s functionality over multiple computers, horizontal distribution involves replicating a server’s functionality over multiple computers.<br>
            A typical example, as shown in Figure, is a replicated Web server.<br>
            In this case each server machine contains a complete copy of all hosted Web pages and client requests are passed on to the servers in a round robin fashion.<br>
            The horizontal distribution architecture is generally used to improve scalability (by reducing the load on individual servers) and reliability (by providing redundancy).<br>

        </div>
    </div>

    <div id="peer to peer" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>Peer to Peer</h3>
        </div>
        <div class="uk-card-body">
            The peer to peer (P2P) architecture takes the opposite approach and assumes that all processes play the same role, and are therefore peers of each other.<br>
            In this architecture, each process acts as both client and server, both sending out requests and processing incoming requests. The P2P model all processes provide the same logical services.<br>
            Well known examples of the P2P model are file-sharing applications.<br>
            When a node wishes to send a message to an arbitrary other node, in this architecture it must first locate that node by propagating a request along the links in the overlay network. Once the destination node is found, the two nodes can typically communicate directly.<br><br>

            There are two key types of overlay networks, the distinction being based on how they are built and maintained. In all cases a node in the network will maintain a list of neighbors.<br>
            In unstructured overlays the structure of the network often resembles a random graph. In order to keep the network connected as nodes join and leave, all nodes periodically exchange their partial views with neighbors, creating a new neighbor list for themselves. As long as nodes both push and pull this information the network tends to stay well connected.<br><br>

            In the case of structured overlays the choice of a node’s neighbors is determined according to a specific structure.<br>
            In a distributed hash table, for example, nodes work together to implement a hash table. Each node is responsible for storing the data associated with a range of identifiers.<br>
            When joining a network, a node is assigned an identifier, locates the node responsible for the range containing that identifier, and takes over part of that identifier space.<br>
            Each node keeps track of its neighbors in the identifier space.<br>

        </div>
    </div>

    <div id="fundamental model" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>Fundamental Model</h3>
        </div>
        <div class="uk-card-body">
            Interaction Model<br>
            Failure Model<br>
            Security Model<br>

        </div>
    </div>

    <div id="keywords" class="content uk-card uk-card-default">
        <div class="uk-card-header">
            <h3>heading</h3>
        </div>
        <div class="uk-card-body">
            content
        </div>
    </div>
</center>

<script src="main.js"></script>
</body>
</html>